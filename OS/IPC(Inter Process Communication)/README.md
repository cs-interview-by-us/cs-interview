# IPC (Inter Process Communication)
- [IPC](#ipc-inter-process-communication-1)

* [IPC 종류](#ipc-종류)
  * [1. 메세지 전달 (Message Passing) ✨](#1-메세지-전달-message-passing-)
    * [메세지 전달 모델의 종류](#-------------)
        + [1. Direct Communication](#1-direct-communication)
        + [2. Indirect Communication](#2-indirect-communication)
    * [메세지 전달 모델 구현 IPC](#-------------ipc)
        + [(1) 파이프](#1-파이프)
        + [(2) 메세지 큐](#2-메세지-큐)
        + [(3) 소켓](#3-소켓)
  * [2. 공유 메모리 (Shared Memory) ✨](#2-공유-메모리-shared-memory-)
    
## IPC (Inter Process Communication)
- 프로세스 간 통신을 위한 통신 방법

## 프로세스 
<img width="640" alt="process" src="https://user-images.githubusercontent.com/31344894/201106055-547d403b-40bb-4f67-aaaa-5db5cce2b2be.png">

- 프로세스는 **완전히 독립된 실행객체**이기에, 다른 프로세스의 영향을 받지 않는다는 장점이 있으나 독립되어 있는 만큼 별도의 설비 없이는 서로 간 통신이 어렵다는 문제가 있습니다. 
- 따라서 **커널 영역**에서 IPC라는 내부 프로세스 간 통신을 제공하게 되고, **프로세스는 커널이 제공하는 IPC 설비를 이용해 프로세스 간 통신을 할 수 있게 됩니다.** 

### 프로세스 간 협력이 필요한 이유
- 자원을 공유하기 위해
- 작업의 속도 향상을 위해
- 모듈화를 위해 

## IPC 종류 
## 1. 메세지 전달 (Message Passing) ✨
<img width="350" alt="message passing" src="https://user-images.githubusercontent.com/31344894/201120991-8712edb0-b5f2-461c-a391-331fbcd0b8af.png">

- 커널 메모리 영역에 메시지 전달을 위한 채널을 만들어서 협력하는 프로세스들 사이에 메세지 형태로 정보를 Send/Receive하는 방법입니다. 

### 동작 방식
- 커널을 경유하여 메세지를 송/수신자끼리 주고 받으며, 커널에서는 데이터를 버퍼링합니다. 
    - A 프로세스가 커널로 메세지를 보내면 커널이 B 프로세스에게 메세지를 보내주는 방식
- 프로세스 간 메모리 공유없이 동작이 가능합니다. 

### 장점 👍
- 커널에서 데이터의 주고 받는 것을 컨트롤할 수 있어 별도의 동기화 로직이 없어도 됩니다. 
### 단점 👎
- 커널을 통해서 데이터를 주고 받기 때문에 Shared Memory 모델보다 느립니다. 

### 메세지 전달 모델의 종류
### 1) Direct Communication
> 통신하려는 프로세스의 이름을 명시적으로 표시하여 메세지를 직접 전달하는 방식 

<img width="484" alt="direct communication" src="https://user-images.githubusercontent.com/31344894/201121620-d0a67dc6-4f17-4d9b-9461-9f210d53de7a.png">

- A 프로세스가 B 프로세스에게 메세지를 전달하고 싶을 때, 수신자 A 프로세스가 메세지를 커널에게 직접적으로 전달한 뒤, 커널이 B 프로세스에게 해당 메세지를 전달하는 방식  
- 프로세스 간 링크는 유일합니다. 
- 대부분 양방향으로 구성됩니다. 

### 2) Indirect Communication
> mailbox(또는 port)를 통해 메세지를 간접 전달하는 방식 

<img width="559" alt="indirect" src="https://user-images.githubusercontent.com/31344894/201121623-4e4b078b-2469-4f3c-a25c-693fc2246824.png">

- A 프로세스가 B 프로세스에게 메세지를 전달하고 싶을 때, 커널 내부 특정 포트에 메세지를 저장해 놓고, B 프로세스가 해당 포트에 접근하여 메세지를 전달하는 방식입니다. 
- port로 전송만 하면 되기에 복잡한 Communication Link를 만들 수 있습니다.
- N:N 관계가 가능합니다.

### 메세지 전달 모델 구현 IPC 
### 1) 파이프 
> 통신을 위한 메모리 공간(버퍼)을 생성하여 프로세스가 데이터를 주고 받게끔 합니다. 

<img width="498" alt="PIPE" src="https://user-images.githubusercontent.com/31344894/201124571-f95e196a-5e4f-4745-8d3a-19bfd135a6e5.png">

<img width="443" alt="pipe 2" src="https://user-images.githubusercontent.com/31344894/201148983-503bcf50-baa2-4a0b-8366-0abe8fffdf23.png">


- 두 개의 프로세스를 파이프로 연결하여 하나의 프로세스는 데이터를 쓰기만하고 다른 프로세스는 데이터를 읽기만 하며 데이터를 통신합니다.
### 특징
- 1:1 통신
- 한 쪽 방향으로만 데이터가 이동
- 주로 부모-자식 간의 단방향 통신으로 사용
- 데이터는 한 쪽 방향으로만 이동합니다(Half-duplex). 따라서 양 방향 통신을 하기 위해서는 두 개의 파이프가 필요합니다.
- 보내진 순서대로 받습니다. (in-order)

### 단점 👎
- 단방향 통신이어서 하나의 파이프를 사용하여 생성하면 데이터의 중복 등의 문제가 발생합니다. 
- 용량 제한이 있기 때문에 파이프가 가득 차면 더 이상 쓸 수 없습니다. 
- 자원 낭비가 심합니다. 
    - 일반적으로 2개의 프로세스가 통신할 때 2개의 파이프를 사용하여 통신합니다.
    - 만약 100개의 프로세스가 통신을 하는 경우에는
    <img width="72" alt="num" src="https://user-images.githubusercontent.com/31344894/201148604-f8eec2e3-1705-4078-9005-75503e273a90.png"> ,  총 9900개의 파이프가 필요합니다.  

### 2) 메세지 큐
>  FIFO 자료 구조를 가지는 큐를 이용하여 데이터를 전송 및 수신하는 방식
- 부모/자식 관계가 아니더라도, 어느 프로세스 간의 데이터 송수신이 가능합니다.
- 양방향 통신이 가능하며, 메세지의 형태는 사용자가 정의하여 사용할 수 있습니다. 
- Message Queue에 쓸 데이터에 번호를 붙임으로써 다수의 프로세스가 동시에 데이터를 쉽게 다룰 수 있습니다.
- 여러 프로세스가 메세지 큐에 동시에 접근이 가능하기에 **동기화가 필요**합니다.


### 장점 👍
- **비동기** 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리할 수 있습니다. (나중 처리 가능)

### 단점 👎
- 데이터가 많이 쌓일 수록 추가적인 메모리 자원이 필요합니다.
- 큐에 데이터를 넣고 나오는 과정에서 오버헤드가 발생합니다. 

### 3) 소켓 
> 네트워크 통신 기법으로 많이 사용되는 방법으로 양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트 간의 대화를 통해 데이터를 주고 받는 방식 

- 네트워크 소켓을 이용하여 Client-Server 구조로 데이터 통신을 하며, **원격에서 프로세스 간 데이터를 공유할 때 사용**합니다. 
- 포트의 도움으로, 다른 IPC와 달리 ✨**프로세스의 위치에 독립적**입니다. 
- 서버 단에서 bind, listen, accept을 진행하여 소켓 연결을 위한 준비를 하고, 클라이언트 단에서는 connect를 통해 서버에 요청하고 연결이 수립된 후, socket에 send함으로써 데이터를 주고 받습니다. 
- 범용적인 IPC로서 양방향 통신이 가능합니다. 

### 동작 방식
- 데이터 교환을 위해 양쪽 PC에서 각각 임의의 포트를 정하고 해당 포트 간의 대화를 통해 데이터를 주고받는 방식입니다.
- 이 때 각각 PC의 포트를 담당하는 소켓은 각각 하나의 프로세스입니다.
- 해당 프로세스는 임의의 PORT를 맡아 데이터를 송수신하는 역할을 진행하는 프로세스인 것입니다. 
- 각각의 PC에서 프로세스를 통해 타 PC 포트에 연결하라는 명령을 보내게 되면 두 프로세스는 서로 확인 과정을 거쳐 연결을 진행하고 연결 후 마치 PIPE 같이 **1 대 1로 데이터를 주고받는 방식**입니다. 

------
## 2. 공유 메모리 (Shared Memory) ✨
<img width="884" alt="shared memory" src="https://user-images.githubusercontent.com/31344894/201121009-25b12b81-43aa-47bc-8914-5c79f3b26b4a.png">

- 두 개 이상의 프로세스들이 주소 공간의 일부를 공유하며 공유한 메모리 영역에 읽기/쓰기를 통해 통신을 수행합니다.
### 동작 방식 
- 프로세스가 공유 메모리 할당을 커널에 요청하면, 커널은 해당 프로세스에 메모리 공간을 할당해줍니다. 
- 이후 어떤 프로세스라도 해당 메모리 영역에 접근할 수 있습니다.
- 공유 메모리가 설정되면, 그 이후의 통신은 **커널의 관여없이 진행이 가능**합니다. 
### 장점 👍
- **중개자 없이 곧바로 메모리에 접근**할 수 있기 때문에 모든 IPC 중에서 ✨**가장 빠르게 작동**할 수 있습니다. 
- 프로그램 레벨에서 통신 기능을 제공하여 자유로운 통신이 가능합니다. 

### 단점 👎
- 메세지 전달 방식이 아니기 때문에 데이터를 읽어야하는 시점을 알 수 없습니다. 
    - 예시로 프로세스 A가 공유 메모리에 데이터를 전달해도 프로세스 B는 그것을 알 수 없습니다. 
    - 따라서 별도의 **동기화 기술이 필요**합니다. 

- 동시에 같은 메모리 위치를 접근하는 위치가 발생할 수 있습니다. 
    - 따라서 공유 메모리에 접근할 프로세스 간의 **Lock 메커니즘이 필요**합니니다. 

### 참고 
- https://dar0m.tistory.com/233
- https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=bycho211&logNo=220985701140
- https://steady-coding.tistory.com/508
