# 데드락(Deadlock)

**두 개 이상의 프로세스나 스레드가 서로 자원을 기다리면서 무한히 기다리게 되는 상태**를 말함

시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생함

*(마치, 외나무 다리의 양 끝에서 서로가 비켜주기를 기다리고만 있는 것과 같음)*

</br>

- 데드락이 일어나는 경우

![Untitled](https://user-images.githubusercontent.com/22094204/201186555-14df2a59-899b-4f53-8730-6fa804e871fe.png)

프로세스1과 2가 자원1, 2를 모두 얻어야 한다고 가정해보자

    - t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음
    - t2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림

현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐

→ 이것이 바로 **DeadLock** !

</br>

- 주로 발생하는 경우 : **멀티 프로그래밍 환경**에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생  

    - 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음. 이때 프로세스는 대기 상태로 들어감
    - 대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 '교착 상태' 발생

</br>

- 데드락의 발생 조건은?
    
    4가지 모두 성립해야 데드락 발생
    
    (하나라도 성립하지 않으면 데드락 문제 해결 가능)
    
    1. **상호 배제(Mutual exclusion)**
        
        > 자원은 한번에 한 프로세스만 사용할 수 있음
        > 
    2. ****점유 대기(Hold and wait)****
        
        > 각 프로세스는 최소 하나 이상의 자원을 점유하면서 다른 자원의 점유가 해제되기를 기다려야 함
        > 
    3. **비선점 (No Preemption)** 
        
        > 할당된 자원은 각 프로세스가 스스로 할당을 해제하기 전까지는 점유를 해제할 수 없어야 함 (=강제로 빼앗을 수 없음)
        > 
    4. ****순환 대기(Circular wait)****
        
        > 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함
        > 

</br>

- 데드락을 해결하는 방안은?  
    1. **예방 (Prevention)**  
    데드락의 네 가지 조건 중 하나를 없애는 것(자원 낭비 엄청 심함)
        1. **상호 배제** 부정 : 모든 프로세스가 자원을 동시에 사용  
        ⇒ 불가능한 방법
        (프린터와 같은 자원은 애초에 공유가 불가능함)  
        
        2. ****점유 대기**** 부정 : 프로세스가 필요한 자원을 한 번에 모두 요청하고 모두 할당받을 수 있을 때만 처리하는 것  
        ex) 도서관에서 5권의 책을 빌려서 공부하기로 했다면, 5권의 책이 모두 대출 가능할 때만 공부를 시작하겠다는 것  
        ⇒ 비효율적인 방법 (자원 분배, Starvation)  
        
        3. **비선점** 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납  
        ⇒  프린터와 같이 선점(Preemption)이 허용되어선 안되는 자원이 있음  
        
        4. ****순환 대기**** 부정: 모든 자원에 우선순위를 정함으로써 Cycle을 없애는 것  
        각 프로세스는 오름차순의 우선순위의 순서로 자원을 요청해야만 함  
        ex) R1의 우선순위 1, R2의 우선순위 2, R3의 우선순위 3이라면  
        R1→R2→R3의 오름차순 요청만 가능  
        ⇒ 자원 분배의 효율성이 떨어짐  
        
    2. **회피 (Avoidance)**   
    Deadlock이 발생할 것 같으면 ***안전상태**까지 기다림   
    (***안정상태**(**Safe State)** : 프로세스들에 자원을 할당해주는 순서가 Dedalock이 발생하지 않는 상태)
    
        
        ![Untitled 1](https://user-images.githubusercontent.com/22094204/201186543-edbc3d9d-9dc8-4773-ab21-d1caa22251ac.png)
        
        1. **자원이 하나**라면, *자원 할당 그래프를 그려서, Cycle이 발생하는 지 확인해봄. Cycle이 발생할 것 같으면 프로세스가 자원 요청을 하지 않는다.
        2. **자원이 여러개**라면, 뱅커 알고리즘을 이용
        </br>
        
       
        >💡 뱅커 알고리즘(Banker’s algorithm)
        >
        > - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래
        > - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
        > - 안정상태면 자원할당, 아니면 다른 프로세스들이 자원 해지까지 대기 
        > 
       
        
        → 할당 자원 수 고정, 프로세스 수 고정, 제한된 시간 안에 자원 반납 등 많은 조건 필요
        
        - 현대 시스템은 자원이 동적이라 현실적으로 불가능한 방법
        - 회피의 오버헤드를 감당할 수 있는 시스템이 현대에서 불가능
    3. **탐지 (Detection) 및 회복(Recovery)**  
    데드락이 발생한 것을 알아차리고, 이를 해결  
    (교착 상태가 자주 발생하는 시스템에서 일반적으로 사용하는 방법)
        1. 탐지
        - **자원이 하나**라면, 자원 할당 그래프를 그려서 Cycle이 있는 지 확인해봄
        Cycle이 있다면 데드락이 발생했을 수도 있다는 뜻
        - **자원이 여러개**라면, 뱅커 알고리즘과 유사하게 데드락 파악  
        
        </br>
        
        2. 회복
        
        데드락이 있다는 것을 탐지했다면 두 가지 방법으로 해결할 수 있음
        
        - 단순히 프로세스를 1개 이상 중단시키기
            - **교착 상태에 빠진 모든 프로세스를 중단시키는 방법**
            계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용이 발생할 수 있음
            - **프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키는 방법**
            매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
        - 자원 선점하기
            - 프로세스에 할당된 자원을 선점해서, 교착 상태를 해결할 때까지 그 자원을 다른 프로세스에 할당해 주는 방법(해당 프로세스 일시정지 시킴)
            - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점
    4. **무시**
    교착 상태가 드물게 발생하는 시스템에서 일반적으로 사용하는 방법 
    (ex. Unix, Window)
        1. 만약 교착 상태가 발생한다면?
        사용자가 직접 프로세스를 죽이거나 시스템 자체를 재부팅시켜버리는 방법으로 해결함
    
    </br>
    
    </br>
    
    > 📍 왜 “예방”과 “회피”보다 “탐지 및 복구”를 사용할까?
    >
    > 1. 교착 상태는 필요악  
    > ⇒ 교착상태가 발생하지 않도록 만드는 것(예방)은 자원을 효율적으로 사용하지 않는 것이기 때문
    > 
    > 2. 오버헤드가 심함
    > - 탐지 및 복구는 교착 상태를 탐지하고 복구하는 전략
    > - 회피는 **자원을 요청할 때마다** 시스템의 상태를 판단하고 회피하는 전략
    
    
    
    </br>
    
 
    [뱅커 알고리즘](https://jhnyang.tistory.com/102)
