# 페이지 교체 알고리즘

## 가상 메모리
> 가상 메모리는 물리 메모리 크기의 한계를 극복하기 위해 나온 기술이며, **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능**하도록 하는 기법입니다. 

- 프로그램이 CPU에서 실행되려면 실행에 필요한 부분이 메모리에 올라와 있어야합니다. 
- 또한, 여러 프로그램이 동시에 수행되는 환경에서는 한정된 메모리 공간을 여러 프로그램이 조금씩 나누어 사용하는데, 이를 위해 **운영체제는 적절히 프로세스에 메모리를 할당**해야합니다.
- 운영체제는 CPU에서 당장 수행해야하는 부분만 **디스크**에 올리고 나머지는 **디스크의 swap 영역**으로 놓았다가 다시 필요해지면 기존에 메모리에 있었던 부분과 **교체**하는 방식을 사용합니다. 

## 요구 페이징 (Demand Paging)
- 프로그램 실행 시 프로세스를 구성하는 모든 페이지를 한꺼번에 메모리에 올리는 것이 아니라, 당장 사용될 페이지만 올리는 방식입니다. 
- 특정 페이지에 대해 CPU의 요청이 들어온 후에 해당 페이지를 메모리에 적재합니다. 

> 가상 메모리는 ```요구 페이징 기법```을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둡니다. 


## 페이지 교체 알고리즘
- 요구 페이징 시스템은 메모리에 필요한 페이지가 있을 때는 잘 진행되지만, 없을 경우에는 문제가 생깁니다. 
- 프로세스가 필요로 하는 페이지가 없는 경우(Page Fault) 하드 디스크에서 페이지를 찾아 빈 프레임에 로딩합니다. 
- 이때, **페이지를 올릴 빈 프레임이 없는 경우** ```새로 올릴 페이지와 교체할 희생 페이지(Victim Page)을 찾는 알고리즘이 페이지 교체 알고리즘```입니다. 

> 프레임: 물리 메모리를 사용하는 최소 크기 단위
> 페이지: 가상 메모리를 사용하는 최소 크기 단위

## Page fault 시, 동작 과정 

<img width="666" alt="page fault" src="https://user-images.githubusercontent.com/31344894/205445077-59bb874a-efc7-45e8-a726-ec50f8b04da7.png">

- valid/invalid bit가 포함된 페이지 테이블을 통해 메인 메모리에 존재하는 지의 여부를 알아낼 수 있습니다. 
- 필요한 페이지가 메모리에는 없는 경우, page fault trap을 발생시킵니다.   
    - 위의 그림에서 ```②trap```의 부분
- Page fault가 자주 발생하면 그만큼 디스크에서 메모리로 페이지를 가져오는 경우가 많아 (I/O) 속도가 느려집니다. 
- 만약, Page fault가 발생하여 필요 페이지를 디스크에서 메모리로 가져오려고 하는데, 메모리에 빈 프레임이 없는 경우 디스크로 Swap Out할 victim page를 선택해야합니다. 


### 1) FIFO(First In First Out) 알고리즘 
> 메모리에 올라온 지 가장 오래된 페이지를 교체하는 기법입니다. 
- 알고리즘을 수행하기 위해 각 페이지가 올라온 시간을 페이지에 기록하거나, 페이지가 올라온 순서를 큐(Queue)에 저장하는 방식을 사용할 수 있습니다. 

<img width="692" alt="fifo" src="https://user-images.githubusercontent.com/31344894/205443552-dda69356-edee-4e26-8cf9-ae14d82151b7.png">

- 장점👍
    - 이해가 쉽고 구현이 간단합니다.
- 단점👎
    - 성능이 항상 좋음을 장담할 수 없습니다. 
    - 활발하게 사용 중인 페이지를 계속해서 교체한다면 페이지 부재율이 높아지고 실행 속도가 떨어질 위험이 있습니다. 


### 2) OPT(Optimal: 최적) 알고리즘 
> 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체하는 기법입니다. 
- OPT 알고리즘이 수행되기 전에 선행되어야 할 전제 조건으로 **프로세스가 앞으로 사용할 페이지를 미리 알아야한다**는 것입니다.

<img width="669" alt="opt" src="https://user-images.githubusercontent.com/31344894/205443693-e7485488-61a4-41c0-a67a-647de3caf7d9.png">

- 장점👍
    - 모든 페이지 교체 알고리즘 중 가장 페이지 교체 수가 적습니다. (성능이 좋습니다)
- 단점👎
    - 전제 조건을 실제 활용에서는 알 수 없기에 OPT 알고리즘은 구현이 불가능합니다. 
- 특징
    - 위 단점 때문에 OPT 알고리즘은 실제 구현 목적보다 다른 알고리즘과 비교 연구 목적을 위해 주로 사용됩니다. 

### 3) LRU (Least Recently Used)
> 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘입니다. 

<img width="703" alt="lru" src="https://user-images.githubusercontent.com/31344894/205444088-186db311-9a3d-4300-a627-734e3a44eb85.png">

- 특징
    - 과거의 데이터를 바탕으로 **페이지가 사용될 시간을 예측**합니다. 
    - 가장 오랜기간 사용되지 않은 페이지를 교체합니다. 
    - 많은 운영체제가 채택하는 알고리즘입니다. 
- 장점👍
    - OPT 알고리즘보다 페이지 교체 횟수가 높지만 FIFO 알고리즘보다 효율적입니다. 

### 4) LFU (Least Frequently Used)
> 참조 횟수가 가장 작은 페이지를 교체하는 알고리즘입니다.

<img width="667" alt="lfu" src="https://user-images.githubusercontent.com/31344894/205444114-a758aca0-7802-4e7f-a17e-a7d60c985866.png">

- 특징
    - 교체 대상인 페이지가 여러 개일 경우, LRU 알고리즘을 따라 가장 오래 사용되지 않은 페이지로 교체합니다. 
- 단점👎
    - 초기에 한 페이지를 집중적으로 참조하다가 이후 다시 참조하지 않는 경우, 앞으로 사용하지 않아도 초기에 사용된 참조 횟수가 높아 메모리에 계속 남아있기 때문에 낭비가 일어납니다. 
    - <img width="673" alt="lfu 2" src="https://user-images.githubusercontent.com/31344894/205444285-e605a7df-ba71-47b9-8ce5-9fa10d6dca9c.png">
    - 구현에 상당한 비용이 들며 LRU 알고리즘만큼 최적 페이지 교체 정책을 구현해내지 못합니다. 

### 5) MFU (Most Frequently Used)
> 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘입니다. 

<img width="683" alt="mfu" src="https://user-images.githubusercontent.com/31344894/205444373-b80ab49a-ccc8-42db-b696-de9e850d8154.png">

- 특징
    - 참조 횟수가 적은 페이지가 최근에 사용된 것이기 때문에 앞으로 사용될 가능성이 높다는 판단입니다. 
- 단점👎
    - 구현에 상당한 비용이 들며 LRU 알고리즘만큼 최적 페이지 교체 정책을 구현해내지 못합니다. 


### 참고
- https://medium.com/pocs/%ED%8E%98%EC%9D%B4%EC%A7%80-%EA%B5%90%EC%B2%B4-page-replacement-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-650d58ae266b
- https://steady-coding.tistory.com/526 
- https://velog.io/@jujube0/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC