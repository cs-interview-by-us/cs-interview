# PCB와 Context Switching
## PCB (Process Control Block)
- PCB는 운영체제가 프로세스를 제어하기 위해 정보를 저장해둔 곳으로, **프로세스의 상태 정보를 저장하는 자료구조**입니다. 
- 운영체제는 빠르게 PCB에 접근하기 위해 ``프로세스 테이블``을 사용하여 각 프로세스의 PCB를 관리합니다. 
![](README/pcb%202.png)
- 프로세스가 생성되면 프로세스에 대한 정보인 Process Metadata를 PCB에 저장합니다. 

### PCB에 저장되어 있는 정보(Process Metadata)
|저장정보|설명|
|-|-|
|포인터|프로세스의 현재 위치를 저장하는 포인터 정보|
|프로세스 현재 상태|프로세스의 각 상태 (생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated))를 저장|
|프로세스 번호|모든 프로세스에는 프로세스 식별자를 저장하는 프로세스 ID 또는 PID라는 고유한 ID가 할당됨|
|프로그램 카운터|프로세스를 위해 실행될 다음 명령어의 주소를 포함하는 카운터 값을 저장함|
|레지스터 정보|누산기, 베이스, 레지스터 및 범용 레지스터를 포함하는 CPU 레지스터에 있는 정보. 스택 포인터(SP) 또한 레지스터 중 하나이며, 시스템 스택 포인터의 Top 주소를 저장|
|메모리 관리 정보|운영체제에서 사용하는 메모리 관리 시스템에 대한 정보가 포함됨. 페이지 테이블, 세그먼트 테이블 등이 포함될 수 있음|
|입,출력 상태 정보|입출력장치, 개방된 파일 목록|

### PCB에 Process Metadata가 저장되는 과정
```
프로그램 실행 -> 프로세스 생성 -> 프로세스 주소 공간에 코드, 데이터, 스택 생성 -> 이 프로세스의 메타 데이터들을 PCB에 저장
```

### PCB가 관리되는 방식
- ✨LinkedList 방식으로 관리됨
- PCB List Head에 PCB들이 생성될 때마다 붙게 됩니다. 
- 주소값으로 연결이 이루어져있는 연결 리스트이기 때문에 삽입, 삭제가 용이합니다.
- 즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료시 제거됩니다. 

## Context Switching
- 현재 진행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 진행할 프로세스의 정보를 PCB에서 읽어 적용하는 과정
- PC(program counter)와 SP(stack pointer)를 PCB에 저장하고, 실제 실행할 때 그 해당 값을 CPU의 적합한 레지스터에 덮어 씌워준 다음 실행합니다. 
- ✨요약: 수행 중인 프로세스를 변경할 때, CPU의 레지스터 정보가 변경되는 것 
### Program Counter 
- 다음에 실행될 명령어의 위치를 가리키는 값
- Context Switching 후, 재실행할 프로세스의 위치를 알 수 있습니다.

### Stack Pointer
- 함수를 호출할 때 지역 변수는 스택에 저장되는데, 이 스택에 데이터가 채워진 위치를 가리키는 레지스터 
- SP가 가리키는 곳까지가 데이터가 채워진 영역이고 이후부터 스택 끝까지는 비어있는 영역입니다. 
![](README/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-11-04%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.45.45.png)

### Context Switching이 필요한 이유
```
CPU는 한 번에 하나의 프로세스만 수행할 수 있습니다.
하지만 실생활에서는 여러 개의 프로세스를 동시에 수행하려고 하는데, 
이때 CPU는 동시에 수행하는 것처럼 보이게 하기 위해 여러 개의 프로세스를 번갈아가며 수행합니다. 
CPU가 프로세스를 바꿔가며 실행하기 위해, 문맥 교환이 필요합니다. 
```

### Context Switching 과정 
![](README/context%20switching%202.png)
1. Process P0이 실행되는 도중, 어떠한 이유로 인터럽트나 시스템 콜이 발생합니다.
	- 예시로 실행 상태에 있는 프로세스 P0이 주어진 시간을 다 사용하여 운영체제에서 스케줄러에 의해 인터럽트 발생
2. P0이 유저 모드에서 커널 모드로 전환되고 P0은 준비 상태가 됩니다. 
3. P0의 프로세스 상태 정보를 PCB에 저장합니다. 
4. P1의 PCB 정보를 통해 CPU 레지스터 정보를 채웁니다.
	- 이때, Program Counter를 통해 어느 명령어를 실행할지 알 수 있고, Stack Pointer를 통해 프로세스의 스택 영역 마지막 주소를 알 수 있습니다. 
5. P1 프로세스를 커널 모드에서 유저 모드로 전환해 실행합니다. 

### Context Switching의 오버헤드 
- Context Switching에 걸린 시간과 메모리 => 오버헤드
- I/O 이벤트가 발생했을 때, 디스크에 명령을 내렸는데 끝날 때까지 기다리면서 CPU가 가만히 있으면 CPU가 낭비되기 때문에 다른 프로세스로 바꿔 CPU를 사용하는 것이 더 이득입니다. 
- ✨오버헤드를 감수하면서 기존 프로세스를 새 프로세스로 바꾸는 것이 더 효율적이라고 판단될 때, 스케줄러는 Context Switching을 합니다. 




