# 페이징 & 세그먼테이션 

## 메모리 관리 기법
- 메모리 관리 기법은 크게 ```연속 메모리 관리```와 ```불연속 메모리 관리```로 나눕니다. 

## 1) 연속 메모리 관리
> 프로그램 전체가 메모리에 **연속적**으로 할당되어야하는 관리 기법 
- 연속 메모리 관리 기법을 사용할 경우, 단편화 현상이 발생합니다.

### 고정 분할 기법
> 물리적 메모리를 정해진 개수만큼의 영구적인 분할로 나누어두고 각 분할에 하나의 프로세스를 적재하는 방식입니다. 

<img width="439" alt="고정 분할 방식" src="https://user-images.githubusercontent.com/31344894/205439142-f5548a04-b5e9-4129-81b1-6af2490578b4.png">

- 특징
    - 분할의 크기는 모두 동일할 수 있고 서로 다를 수도 있습니다. 
- 단점👎
    - **내부 단편화, 외부 단편화가 발생**합니다. 

### 가변 분할 기법 
> 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식입니다. 

<img width="404" alt="가변 분할 방식" src="https://user-images.githubusercontent.com/31344894/205439175-a959022e-73ed-44ae-9038-fa79085a527e.png">


- 특징
    - 프로그램의 크기를 고려해서 메모리를 할당하고 이를 기술적으로 관리할 수 있는 기법이 필요합니다.
        - (1) First-fit (최초 배치)
            - ```가장 먼저 나오는 가용 가능한 메모리 공간```에 프로세스를 올리는 방식
            - 빈 공간을 탐색할 시간을 줄일 수 있지만 단편화 고려하지 않습니다. 
        - (2) Best-fit (최적 배치)
            - ```가장 딱 맞는 메모리 공간```을 찾아 프로세스를 올리는 방식
            - 단편화의 크기를 줄일 수 있지만 탐색하는 시간이 필요하고 아주 작은 단편화가 생겨버려 단편화가 많아질 수 있습니다. 
        - (3) Worst-fit (최악 배치)
            - ```가장 큰 메모리 공간```에 프로세스를 올리는 방식 
            - 남은 공간이 크기 때문에 추후 사용할 수 있지만, 탐색 시간이 오래걸리고 당장에 큰 단편화를 발생시켜 효율이 좋지 않습니다. 
- 장점👍
    - 프로세스에 딱 맞게 메모리 공간을 사용하기에 내부 단편화 문제는 발생하지 않습니다. 
- 단점👎
    - 사용 중인 프로세스가 종료되어 메모리에 새로운 프로세스를 올릴 메모리 공간이 충분하지 않을 경우 **외부 단편화가 발생**합니다.  

### 단편화 (Memory Fragmentation)
> 기억 장치의 빈 공간 또는 자료가 여러 조각으로 나뉘는 현상입니다. 
> 
> 컴퓨터에서 어떤 프로그램을 실행할 때, 메모리의 공간을 연속적인 형태로 할당하여 사용하게 됩니다.  
> 이렇게 프로그램이 메모리에 할당되고 해제되고, 다시 새로운 프로그램이 할당되는 과정을 반복하다보면 
>  
> ❗️**메모리 공간이 조각조각 나뉘게 되어 실제로는 사용 가능한 메모리가 충분하지만, 할당이 불가능한 상태가 발생하게 됩니다.**

### 단편화 - (1) 내부 단편화✨
> 내부 단편화는 프로세스에 할당된 메모리 공간이 **실제로 프로세스가 필요한 공간보다 많이 할당되었을 때**, 프로세스에서 사용하는 메모리 공간이 낭비되는 상황입니다. 

<img width="475" alt="내부 단편화 1" src="https://user-images.githubusercontent.com/31344894/205438467-639e2211-7472-43eb-aabb-2e2b3d62cd53.png">

- 100MB의 메모리에 80MB 크기의 프로세스를 올리게 되면, 

<img width="424" alt="내부 단편화 2" src="https://user-images.githubusercontent.com/31344894/205438464-d02977c2-ce20-4b12-b37e-c971e23763f5.png">

- 20MB의 내부 단편화가 발생하게 됩니다.
- 20MB의 공간은 너무 작아 다른 프로세스들이 사용하지 못하게 되어 내부적으로 낭비가 됩니다. 

### 단편화 - (2) 외부 단편화✨
> 외부 단편화는 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적이지 않아 발생하는 현상입니다. 

<img width="668" alt="외부 단편화 1" src="https://user-images.githubusercontent.com/31344894/205438694-f5993371-1723-453a-b9ef-12e9db81d92d.png">

- 남아있는 메모리 공간은 50MB + 50MB = 100MB로 요청한 메모리 공간 80MB보다 크지만, 남아있는 공간이 연속적이지 않아 프로세스를 할당할 수 없게 됩니다.


## 2) 불연속 메모리 관리
> 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법입니다.  
> 
> 단편화 문제를 해결하기 위해 제시된 기법으로 **외부 단편화 회소를 위한 페이징**과 **내부 단편화 해소를 위한 세그먼테이션**으로 나뉩니다. 

## 페이징(Paging)
> 프로세스의 주소 공간을 **페이지(Page)란 단위의 고정된 사이즈**로 나누어 물리적 메모리에 불연속으로 저장하는 방식입니다.

<img width="535" alt="paging" src="https://user-images.githubusercontent.com/31344894/205442282-9df330ae-a598-440c-bb5e-11e59a8aea99.png">


- 프로세스는 페이지 단위로 나누어지고, 물리 메모리는 프레임 단위로 나눠집니다. 
- ✨페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소를 저장합니다. 
- CPU는 논리 주소로 프로그램이 설정한대로 ```연속적인 주소값```으로 명령을 내리고 이는 메모리로 가기 전에 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경합니다. 

- 장점👍
    - 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 ```외부 단편화가 발생하지 않습니다.```

- 단점👎
    - 만약 프로세스가 프레임의 정수배보다 살짝 작다면 할당된 마지막 프레임은 전부 사용되지 않고 남아버리는 ```내부 단편화가 발생```합니다. 
    - 페이지가 클수록 내부 단편화가 커집니다. 

## 세그먼테이션(Segmentation)
> 세그먼테이션은 프로그램의 **논리적인 내용 단위**로 프로세스의 메모리 공간을 분리하는 기법입니다. 

<img width="540" alt="segmentation" src="https://user-images.githubusercontent.com/31344894/205442299-46c92696-718a-427c-a6f4-8686b53adb6f.png">

- 논리적인 내용 단위의 예시
    - 함수 단위: method, procedure, function, object, stack ...
    - C 컴파일러 관점에서의 표준 C 라이브러리 단위: 코드, 전역 변수, 힙, 스택 ... 
    - 위 단위들로 구분지어 나누는 것입니다. 
- 논리적인 내용의 단위로 자르기 때문에 ✨세그먼트들의 크기는 일반적으로 같지 않습니다. 
- 세그먼트 테이블은 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)을 엔트리로 가집니다. 
- CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료합니다. 

- 장점👍
    - ```내부 단편화 문제가 해결```됩니다.
    - 보호와 공유 기능을 수행할 수 있습니다.
        - 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고, 같은 코드 영역은 한 번에 저장할 수 있습니다. 
- 단점
    - ```외부 단편화가 발생```할 수 있습니다.


### 참고
- https://code-lab1.tistory.com/54
- https://velog.io/@nnnyeong/OS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98
- https://bellog.tistory.com/159