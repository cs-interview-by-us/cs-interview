# Blocking, Non-blocking & Synchronous, Asynchronous
## Blocking & Non-Blocking
- __제어권__의 관점으로 접근
- ```호출된 함수```가 ```호출한 함수```에게 제어권을 주느냐 주지 않느냐의 차이  
즉, ```호출된 함수```가 바로 실행될 수 있는지 없는지의 차이  

### Blocking
- ```호출된 함수```가 자신의 작업이 종료되기 전까지 ```호출한 함수```에게 제어권을 돌려주지 않는 것

### Non-Blocking
- ```호출된 함수```가 자신의 작업이 종료되지 않아도 제어권을 바로 ```호출한 함수```에게 넘겨주어 ```호출한 함수```가 다른 일을 할 수 있도록 하는 것

<br>

## Synchronous & Asynchronous
- __시간__ 관점으로 접근
- 함수A가 함수B를 호출하여 작업을 수행할 때 __해당 작업의 완료 여부를 신경쓰는지__에 따라 구분

### Synchronous
- 요청과 그 결과의 시간이 맞춰져야 함  
즉, 스택에서 함수 하나가 빠져 나가고, 다음 함수가 실행이 되고, 이런 느낌으로 시간이 지켜지면서 순차적으로 일어날 수 있는 것  
- 호출하는 함수가 해당 작업의 결과 값을 받아서 다음 작업을 수행

### Asynchronous
- 요청과 그 결과의 시간이 완전히 맞춰지지 않음  
즉, 호출된 함수의 결과값을 받게 되는데 다른 비동기 함수로 부터 받은 결과값에 대해 모든 순서가 완전히 보장이 될 수는 없다는 것  
- 호출하는 함수는 해당 작업의 결과 값을 상관하지 않고, 호출되는 함수가 콜백으로 결과 값을 넘겨주는 방식 등으로 결과 처리

<br>

## 조합
![](https://velog.velcdn.com/images/imeyh/post/5ed4476b-9688-4b26-a0cb-f45e38986170/image.png)
### Sync-Blocking
> 함수가 다른 함수를 호출하면 호출한 함수는 block되고 호출된 함수가 종료되면 그 결과를 return받아 다음 코드를 이어나감

### Async-NonBlocking
>함수가 다른 함수를 호출하면 호출한 함수는 block되지 않고 호출된 함수의 작업 결과에 상관없이 바로 이어서 코드를 실행  
호출된 함수는 작업을 수행하고 그 결과를 callback으로 반환  

### Sync-NonBlocking
![](https://velog.velcdn.com/images/imeyh/post/ea431611-6d40-4533-abb9-6eabbe81f27a/image.png)
>제어권을 호출된 함수에게 넘겨주지 않음 = Non-Blocking  
But, 함수 결과값의 순서는 보장 = Synchronous  

- 제어권을 ```호출된 함수```에게 넘겨주지 않기 때문에(Non-Blocking) 프로그램 측에서는 ```호출한 함수```가 끝나기를 기다리면서 다른 작업들을 수행할 수가 있음  
하지만 Synchronous하기 때문에, 시간을 맞춰주기 위해 매 시간 호출된 함수가 끝났는지 테스팅하는 요청이 필요  

### Async-Blocking
![](https://velog.velcdn.com/images/imeyh/post/cc4b52cd-838e-471c-b400-861ea41f5ce0/image.png)
>제어권을 호출된 함수에게 넘겨줌 = Blocking  
But, 함수 결과값의 순서는 보장되지 않고 결과를 바탕으로 이루어짐 = Asynchronous  

- 호출한 함수는 제어권을 호출된 함수에게 넘겨주어버렸으므로(Blocking) 다른 작업들을 할 수가 없음  
호출된 함수에 대한 결과값의 응답을 받은 후, 제어권 또한 넘겨받게 되어 다른 작업들이 실행됨(~~그럼 왜 굳이 Asnyc? 라는 생각이 들 수 밖에 없음~~-_-)  
- 매우 비효율적이기 때문에 직접적으로 사용하는 모델은 거의 없음  
 ```Node.js와 MySQL을 함께 사용하는 경우```와 같이 환경이 다른 두 프로그램을 혼합에서 사용하면서 겪게 되는 희귀한 경우  
