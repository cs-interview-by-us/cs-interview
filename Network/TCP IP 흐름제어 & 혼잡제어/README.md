# TCP/IP 흐름제어 & 혼잡제어
## TCP 통신이란?
- 네트워크 통신에서 신뢰적인 연결방식
- TCP는 기본적으로 unreliable network에서, reliable network를 보장할 수 있도록 하는 프로토콜
- TCP는 network congestion avoidance algorithm을 사용

>__reliable network를 보장할 때 존재하는 문제__
>1. 손실 : packet이 손실될 수 있는 문제
>2. 순서 바뀜 : packet의 순서가 바뀌는 문제
>3. Congestion : 네트워크가 혼잡한 문제
>4. Overload : receiver가 overload 되는 문제


## 흐름제어(Flow Control)
- 수신측의 데이터 처리 속도 < 송신측의 데이터 전송 속도일 경우 문제 발생하므로 송식측과 수신측 사이의 데이터 처리 속도 차이를 해결하기 위한 기법
- 수신측의 buffer는 제한적인 크기이므로 이 크기를 초과한 이후 도착하는 데이터는 손실될 수 있음 이러한 위험을 줄이기 위해 송신측의 데이터 전송량을 수신측에 따라 조절해야 함

### 해결방법
#### 1. Stop and Wait
- 매번 전송한 패킷에 대해 확인 응답(ACK)을 받아야만 그 다음 패킷을 전송하는 방법

![](https://velog.velcdn.com/images/imeyh/post/e2f3338a-cda5-43e9-ba30-5ea5b2636250/image.png)

👎🏻패킷을 하나씩 보내기 때문에 비효율적

#### 2. Sliding Window
- 수신측에서 설정한 윈도우 크기만큼 송신측에서 패킷 각각의 확인응답(ACK)없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법

![](https://velog.velcdn.com/images/imeyh/post/e76a64c1-8704-4fe4-845c-3c076c01f828/image.png)
- 동작방식 : 먼저 윈도우에 포함되는 패킷을 계속 전송하고, 그 패킷들의 전달이 확인되는대로 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송

<동작예시>

![](https://velog.velcdn.com/images/imeyh/post/a1a4dcb5-3c9a-44c0-aeb6-3140f7c5b618/image.png)
1. 데이터 1, 2를 전송함. 그럼 송신측의 윈도우는 데이터 3, 4, 5만큼 윈도우의 크기가 줄어듦(이미지엔 표현X)
2. 수신측은 0, 1 데이터를 정상적으로 수신했음을 알리는 ACK를 보냄
3. 송신측은 ACK를 받고 ACK의 프레임 수만큼 오른쪽으로 윈도우 이동

## 2. 혼잡제어(Congestion Control)
- 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 기법
- 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 혼잡제어라고 함

> 흐름제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를포함한 보다 넓은 관점에서 전송 문제를 다룸

### 해결 방법

#### 1. AIMD(Additive Increase / Multiplicative Decrease)
- 처음에 패킷을 하나씩 보내고 문제없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송하는 방법
- 만약 전송에 실패하면 윈도우 크기를 반으로 줄임

👊🏻여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴  
👎🏻윈도우 크기를 너무 조금씩 늘리기 때문에 초기 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 됨  
👎🏻네트워크가 혼잡해지는 상황을 미리 감지하지 못함. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식  


#### 2. Slow Start(느린 시작)
- 윈도우의 크기를 1, 2, 4, 8... 과 같이 2배씩 증가(지수함수 꼴로 증가)시키는 방법
- 혼잡이 감지되면 윈도우 크기를 1로 줄임

> 처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 예상 가능  
> -> 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 window 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가  

#### 3. Fast Retransmit(빠른 재전송)
![](https://velog.velcdn.com/images/imeyh/post/d9f23f67-0a57-4579-ade8-7d9fb22da8f4/image.png)
> 데이터가 순서대로 와야하는데 순서대로 도착하지 않는 경우가 발생 가능  
> ->수신측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보냄  
> ->이런 중복 ACK를 3개 받으면 재전송 발생  

👍🏻송신측은 자신이 설정한 타임아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 전송률을 유지가능  
👊🏻약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄임  

#### 4. Fast Recovery (빠른 회복)
- 혼잡한 상태가 되면 window size를 반으로 줄이고 선형증가시키는 방법
- 혼잡 상황을 한번 겪고 나서부터는 AIMD 방식으로 동작

## 예상질문
Q1. 흐름제어와 혼잡제어에 대해 간략히 설명하세요  
Q2. 흐름제어 기법 중 하나인 stop and wait 방법이 잘 사용되지 않는 이유는?  
Q3. TCP 통신에서 흐름제어와 혼잡제어를 하는 이유는?  


